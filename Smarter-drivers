import random
import numpy as np
import random
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
import pandas as pd


class Car:
    def __init__(self, initial_position, initial_velocity, max_acceleration = 3, max_deceleration = 5,
                 length = 4, number = 1, reaction_time = 0.75):
        self.position = initial_position
        self.a_max = max_acceleration
        self.a_min = max_deceleration
        self.v = initial_velocity
        self.length = length
        self.number = number
        self.reaction_time = reaction_time
        self.distance_to_next = 1
        self.next_speed = 9999
        
    
    def __repr__(self):
        return 'V:'+str(self.v)+' P:'+str(self.position)+' D:'+str(self.distance_to_next)
    

    def change_speed(self, v_max, p, dt):
        n = np.trunc(self.next_speed / (self.a_min * dt))
        m = np.trunc(self.v / (self.a_min * dt))
        initial_speed = self.v
        critical_speed = np.trunc(self.distance_to_next + n * dt * self.next_speed + dt**2 * self.a_min * n * m *(n+1) * (n-1)/(m*dt + self.reaction_time))
        
        # accelerate
        if self.v < critical_speed and v_max > self.v:
            self.v = min([self.v + dt * np.trunc((self.a_max + 1) * np.random.uniform()), v_max, critical_speed])
        
        # decelerate
        elif self.v > critical_speed:
            
            self.v = max([self.v - dt * np.trunc((self.a_min + 1) * np.random.uniform()), critical_speed, 0])
        
        # randomise
        if self.v >= self.a_min * dt and np.random.uniform() < p:
            
            self.v = max([self.v - dt * np.trunc((self.a_min + 1) * np.random.uniform()), initial_speed - self.a_min * dt, 0])
            

    def move(self, dt):
        self.position += self.v * dt
        
        
class Road:
    def __init__(self, length, density, p, dt, v_max):
        self.length = length
        self.p = p
        self.density = density
        self.v_max = v_max
        self.dt = dt
        self.dx = dt**2
        self.num_positions = int(self.length/self.dx)
        self.cars = [None for i in range(self.num_positions)]
        
    def __repr__(self):
        return str(self.cars)
        
    def average_v(self):
        vs = [car.v for car in self.cars if car != None]
        return np.array(vs).mean()
            
    def next_car(self, car):
        distance_to_next = self.dx
        position = int(car.position/self.dx)
        for i in range(1, int(self.num_positions - position)):
            
            if self.cars[position + i] == None:
                distance_to_next += self.dx
            else:
                car.next_speed = self.cars[position + i].v
                distance_to_next -= self.cars[position + i].length
                break
            
            if position + i == self.num_positions - 1:
                distance_to_next += 999
                car.next_speed = self.v_max
        
        if position == self.num_positions - 1:
            distance_to_next += 999
            car.next_speed = self.v_max
            
        car.distance_to_next = distance_to_next
        
        

    def timestep(self):
        # assigning car distances
        for car in self.cars:
            if car != None:
                self.next_car(car)
        
        # making copy for new road
        next_road = [None for i in range(self.num_positions)]
        # move cars
        for car in self.cars:
            # if not an empty slot
            if car != None:
                car.change_speed(self.v_max, self.p, self.dt)
                car.move(self.dt)
                # think I need to add 1 here
                if car.position < self.length:
                    next_road[int(car.position/self.dx)] = car
           
        # new car entering
        if next_road[0] == None and random.random() < self.density: #* self.average_v():
            next_road[0] = Car(initial_position = 0, initial_velocity = 0)
        
        self.cars = next_road
        
    def road_to_values(self):
        vals = []
        for car in self.cars:
            if car == None:
                vals.append(-1)
            else:
                vals.append(car.v)
        return vals

# checking on small example
road = Road(length=5, density=.3, p=0, v_max=5, dt = 0.5)
for i in range(10):
    print(road.road_to_values())
    road.timestep()


# simulation + animation

dt = 0.25
length = 2240
density = .3
p_ = 0
v_max = 27
T = 200

t_vals = np.arange(int(T/dt)+1)

# my_road = Road(length = length, density = density, p = p_, v_max = v_max, dt = dt)

# # x_vals = []

# # for t in t_vals:   
# #     x_vals.append(my_road.road_to_values())
# #     my_road.timestep()
    
# #generating coordinates
# coords = []

# for t in t_vals:
#     for p, v in enumerate(x_vals[t]):
#         if v != -1:
#             coords.append((t * dt, p * dt**2, v))

# df = pd.DataFrame(data = coords, columns = ['t', 'p', 'v'])
# print(df['v'].mean())

# from IPython import display

# def animation_function(t):
#     plt.clf()

#     data = df[df['t'] == t*dt]

#     ps = data['p']
#     vs = data['v']

#     plt.scatter(x = ps, y = np.zeros(len(vs)), c = vs)#, s = 30
#     plt.title(f"Simulating with  $p = {p_}$, $t = {t*dt:.2f}$")
#     plt.xlim([0,int(length)])
#     plt.ylim([-0.01, 0.01])

# fig = plt.figure(figsize=(8,1.6))
# anim = animation.FuncAnimation(fig, animation_function, frames = int(T/dt), interval = 50)

# # converting to an html5 video
# video = anim.to_html5_video()
  
# # embedding for the video
# html = display.HTML(video)
  
# # draw the animation
# display.display(html)
# plt.close()


raw_data = pd.read_csv('Data/2014 TMU Site 3976 (AL3328).csv')

raw_data[' Total Carriageway Flow'].replace('', np.nan, inplace=True)
raw_data.dropna(subset=[' Total Carriageway Flow'], inplace=True)
traffic_data = raw_data

fig, ax = plt.subplots(1, 1, figsize = (7,7), dpi = 200)

traffic_data.plot.scatter(x = ' Total Carriageway Flow', y = ' Speed Value', marker = '.', color = 'Navy', label = '2014 TMU Site 30014795 (AL1850)', ax = ax)

def avg(road):
    speeds = []
    for car in road.cars:
        if car != None:
            speeds.append(car.v)

    if len(speeds) != 0:
        return np.asarray(speeds).mean()

    return 0

flowrates = np.arange(1, 600, 1)
avg_speeds = []

for flowrate in flowrates:

    dt = 1
    length = 5
    density = .3
    p_ = 0
    v_max = 27
    T = 200
    t_vals = np.arange(int(T/dt)+1)

    density = flowrate / length
    myroad = Road(5, density, 0, 27, .25)
    print(myroad)
    for t in t_vals:
        myroad.timestep
    avg_speeds.append(avg(myroad))

#print(myroad)
#print(avg_speeds)
avg_speeds = np.asarray(avg_speeds)

ax.scatter(flowrates, avg_speeds, color = 'Crimson', marker = '.', label = 'Simulated data')

fig.savefig('Smart Drivers', bbox_inches = 'tight')